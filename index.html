<!DOCTYPE html>
<html>
<head>
<title>Visualization of shit</title>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="/circularHeatChart.js" charset="utf-8"></script>
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="http://underscorejs.org/underscore-min.js"></script>
<script src="nv.d3.min.js"></script>
<link href="nv.d3.css" rel="stylesheet" type="text/css">

<style>
body {
	font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
	margin: 2%;
}

#wrapper{width:1500;overflow: hidden;}
#nation{width:1000px; height:700px; float:left; fill:#ccc;}
#mostFreqColors{overflow:hidden;}

</style>
</head>

<body>

<div id="dataviztest">
    <h1>Reference Hues</h1>
    <svg id="test2" class="mypiechart"></svg>
    <h1>Full Aggregate</h1>
</div>
<div id="wrapper">
	<div id="nation"></div>
	<div id="mostFreqColors"></div>
</div>

<script type="text/javascript">

// Testing data structure's visualization

var cities = ["boston", "chicago", "dc", "houston", "la", "minneapolis", "seattle"]
var monthNames = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ];

var refHueNames = [ "Red", "Red-Yellows", "Yellows", "Yellow-Greens", "Greens", 
    "Green-Cyans", "Cyans", "Cyan-Blues", "Blues", "Blue-Magentas", "Magentas", 
    "Magenta-Reds"];

var data = {}

function loadData(callback) {
    counter = 0
     _.each(cities, function(city) {
        data[city] = {} // omg fuck javascript and their stupid associative arrays
        _.each(_.range(1, 13), function(month) {
            month_string = month < 10 ? "0" + month : month;
            date = "2011-" + month_string + "-01";
            month_path = "imageanalysis/out/" + city + "/" + date + ".json"

            $.getJSON(month_path, function(json) {
                data[city][month] = json
                counter++;

                if (counter == cities.length * 12) {
                    callback();
                }
            });

            
        });
    });

     
};

function getRefMonthData(city, month) {
    var hue_data =[];
    var tot_hue_perc = 0;
    // gets the reference data and makes the comparison target thing
    month_data = data[city][month]

    reference = month_data.ref_aggregate
    for (var hue in reference.hues){
        hue_data.push({"hue" : hue, "percent" : reference.hues[hue].percentage}); 
    }; 

    return hue_data;
}

function getMonthData(city, month) {
    // gets the reference data and makes the comparison target thing
    month_data = data[city][month]

    // gets average color for every aggregated hue
    var agg_hue_data = [];
    var agg_hue_perc = 0;
    aggregate = month_data.aggregate
    for (var hue in aggregate.hues){
        var avg_light = aggregate["hues"][hue]["total_light"] / aggregate["hues"][hue]["count"];
        var avg_sat = aggregate["hues"][hue]["total_sat"] / aggregate["hues"][hue]["count"];
        var avg_hue = d3.hsl(hue, 0.75, 0.5);
        agg_hue_data.push([avg_hue, 1 - agg_hue_perc]);
        agg_hue_perc += aggregate.hues[hue]["percentage"];
    };

    return agg_hue_data;
};

function displayReferenceChart(city, month) {
    hue_data = getMonthData(city, month);

    var svg = d3.select("#dataviztest").append("svg")
        .attr("width", 600)
        .attr("height", 600);

    var g = svg.selectAll("g")
        .data(hue_data)
        .enter().append("g")
        .attr("transform", "translate(" + [200, 200] + ")");

    g.append("circle")
        .attr("cx", 10)
        .attr("cy", 10)
        .attr("r", 100)
        .attr("transform", function(d) { 
            scaling_factor = d[1];
            transform_factor = -(10 * scaling_factor - 1)

            // Translates and scales the circles so that they're concentric
            translate = "translate(" + transform_factor + "," + transform_factor + ")";
            scale =  "scale(" + d[1]+ ")"; 

            return translate + " " +  scale
        })
        .attr("fill", function(d) { return d[0]});
        //return d3.hsl(d[0], 1, 0.5) });

    svg.append("text").attr("id", "month_label")
        .attr("x", 175).attr("y", 75)
        .text(monthNames[month - 1])

};

function addReferencePieChart(city, month) {
    nv.addGraph(function() {
        var width = 500,
            height = 500;

        ref_data = getRefMonthData("boston", month);
        var chart = nv.models.pieChart()
            .x(function(d) { return refHueNames[d.hue / 30]  })
            .y(function(d) { return d.percent * 100})
            .color(function(d) { return d3.hsl(d.data.hue, 0.5, 0.5) })
            .width(width)
            .height(height)
            .showLegend(false);

          d3.select("#test2")
              .datum(ref_data)
            .transition().duration(1200)
              .attr('width', width)
              .attr('height', height)
              .call(chart);

        return chart;
    });
}


// ----------- Entry point ----------
$(function() {
    // First we load all the data and do all the things we need the data for (chart drawing) in the callback
    loadData(function() {
        month = 1
        // This is the first display
        displayReferenceChart("boston", month);

        //displayReferenceChart("seattle", month);
        /*for (var city in cities){
            displayReferenceChart(cities[city], month);
        }*/

        updateDelay = 1000
        // then it updates every updateDelay ms
        setInterval(function() {
            month = month > 12 ? 1 : month;
            new_data = getMonthData("boston", month);
            circle = d3.selectAll("circle").data(new_data);

            circle.transition()
                .attr("transform", function(d) { 
                    scaling_factor = d[1];
                    transform_factor = -(10 * scaling_factor - 1)
                    // Translates and scales the circles so that they're concentric
                    translate = "translate(" + transform_factor + "," + transform_factor + ")";
                    scale =  "scale(" + d[1]+ ")"; 
                    return translate + " " +  scale
                }).attr("fill", function(d) { return d[0]});
                //return d3.hsl(d[0], 1, 0.5) });

            d3.selectAll("#month_label").text(monthNames[month - 1]);   

            month++;
        }, updateDelay);   
        addReferencePieChart("boston", month)
    });

});






// nation visualization
var path = d3.geo.path();

var svg = d3.select("#nation").append("svg")
    .attr("width", 960)
    .attr("height", 500);

d3.json("/us.json", function(error, topology) {
  svg.append("path")
      .datum(topojson.feature(topology, topology.objects.land))
      .attr("d", path);
});


// This is a modified version of the circular heat chart at http://prcweb.co.uk/lab/circularheat/
//loadData(function(){
var chart_data = [];
/*
for (var ci in cities){
    for (var mo = 1; mo < 13; mo++){
        var avg_color = 0;
        console.log(data["boston"][1])
        city_data = getMonthData(cities[ci], mo);
        ci_aggregate = city_data.aggregate
        for (var hue in ci_aggregate.hues){
            avg_color += hue * ci_aggregate.hues[hue]["percentage"];
            
        };
        var new_hue = d3.hsl(avg_color, 0.75, 0.5);
        chart_data.push(new_hue);
    }
};*/

for(var i=0; i<(5*12); i++) chart_data[i] = Math.random();

var chart = circularHeatChart()
    .innerRadius(20)
    .range(["white", "#cca"])
    .radialLabels(["Boston", "Chicago", "Houston", "Los Angeles", "Seattle"])
    .segmentLabels(["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sept", "Oct", "Nov", "Dec"]);

d3.select('#mostFreqColors')
    .selectAll('svg')
    .data([chart_data])
    .enter()
    .append('svg')
    .call(chart);
//});
</script>
</body>
</html>

